/*
 * Relationship_TrackingUserAndProducts.c
 *
 *  Created on: 14 may 2022
 *      Author: gonza
 */

#include "Relationship_TrackingUserAndProducts.h"
#include "General.h"
#include "User.h"
#include "Product.h"
#include "Tracking.h"
#include "Product.h"
#include "TimeFunctions.h"

static int idTrackingAI = 2000;
static int Tracking_GetUniqueId() {
	return idTrackingAI++;
}

static int idProductAI = 3000;
static int Product_getUniqueId() {
	return idProductAI++;
}

int Relationship_BuyProductAndNewTracking(Product productList[], int size,
		Tracking trackingList[], int trackingSize, User buyer) {
	int r = -1;
	int indexBuy;
	int stockToBuy;
	float totalPrice;
	int ID = 0;

	if (productList != NULL) {
		if (size > 0) {
			Product_printProducts(productList, size, INPROCESS);
			if (utn_getNumero("Ingrese el ID del producto a comprar:\n",
					"Hubo un error\n", 0, 3, &ID) == 0) {
				indexBuy = Product_SearchIndexPerId(productList, size, ID,
				INPROCESS);
				if (indexBuy == -1) {
					printMessage("No se encontro el ID en la lista.\n", 1);
				} else {
					printMessage(
							"El producto que desea comprar es el siguiente:\n",
							1);
					Product_printOne(productList[indexBuy]);
					utn_getNumeroWithMax(
							"Ingrese la cantidad de elementos que desea comprar.\n",
							"Ha habido un error, vuelva a intentarlo.\n", 0,
							productList[indexBuy].stock, 3, &stockToBuy);
					totalPrice = stockToBuy * productList[indexBuy].price;
					printf("Precio final: %.2f\n", totalPrice);
					if (confirmation(
							"¿Esta seguro que quiere comprar?(1-Si/Otro numero-No)\n",
							"Ha habido un error en relacion al numero ingresado. Intentelo nuevamente.\n")
							== 1) {
						productList[indexBuy].stock =
								productList[indexBuy].stock - stockToBuy;
						productList[indexBuy].isEmpty = INPROCESS;
						if (productList[indexBuy].stock == 0) {
							productList[indexBuy].isEmpty = NOSTOCK;
						}

						//Alta de tracking
						Relationship_newTracking(trackingList, trackingSize,
								buyer.idUsuario, buyer.postalCode,
								productList[indexBuy].idSeller,
								productList[indexBuy].idProduct, stockToBuy);
						r = 0;

					} else {
						r = -2;
					}
				}
			}

		}
	}
	return r;
}

int Relationship_SellProduct(Product productList[], int size, User seller) {
	int r = -1;
	Product auxProduct;

	if (productList != NULL && size > 0) {
		int indexProduct = Product_SearchSpace(productList, size, FREE);

		if (indexProduct != -1) {
			printf(
					"Categorias:\nModa: 1\nTecnologia: 2\nConstruccion: 3\nElectrodomesticos: 4\n");
			auxProduct = Product_LoadProduct();
			auxProduct.idProduct = Product_getUniqueId();
			auxProduct.isEmpty = INPROCESS;
			auxProduct.idSeller = seller.idUsuario;
			productList[indexProduct] = auxProduct;
			r = 0;
		}
	}
	return r;
}

int Relationship_newTracking(Tracking trackingList[], int trackingSize,
		int idBuyer, int postalCode, int idSeller, int productId,
		int stockToBuy) {
	int r = -1;
	Tracking auxTracking;
	int distanceKM;
	long int timeArrival;
	char sTimeArrival[4096];

	int indexFree = Tracking_SearchSpace(trackingList, trackingSize, FREE);

	if (indexFree != -1) {
		auxTracking.idTracking = Tracking_GetUniqueId();
		auxTracking.idProduct = productId;
		auxTracking.quantity = stockToBuy;
		auxTracking.idBuyer = idBuyer;
		auxTracking.idSeller = idSeller;
		CalculateDistance(postalCode, &distanceKM);
		CalculateArrivalTime(distanceKM, &timeArrival);
		strncpy(sTimeArrival, ctime(&timeArrival), 4096);
		auxTracking.isEmpty = OCCUPIED;
		trackingList[indexFree] = auxTracking;
		printf(
				"ID tracking: %d\nID Product:%d\nID de comprador:%d\nID de vendedor:%d\nStock:%d\nCodigo postal del comprador:%d\nTiempo estimado de llegada: %s\n",
				trackingList[indexFree].idTracking,
				trackingList[indexFree].idProduct,
				trackingList[indexFree].idBuyer,
				trackingList[indexFree].idSeller,
				trackingList[indexFree].quantity, postalCode, sTimeArrival);
		r = 0;
	}

	return r;
}

int Relationship_checkTrackings(Tracking trackingList[], int trackingSize,
		Product productList[], int productSize, User buyer) {
	int r = -1;
	int option;

	if (trackingList != NULL && trackingSize > 0 && buyer.idUsuario > 0 && productList != NULL && productSize > 0) {
		int indexBuyer = Tracking_SearchIndexPerId(trackingList, trackingSize,
				buyer.idUsuario);
		int indexProduct = Product_SearchIndexPerId(productList, productSize,
				trackingList[indexBuyer].idProduct,
				INPROCESS);
		if (indexBuyer != -1 && indexProduct != -1) {
			for (int i = 0; i < trackingSize; i++) {

				if (trackingList[indexBuyer].arrivingTime < time_Current()) {
					productList[indexProduct].isEmpty = DELIVERED;
					printf("¡El producto %s ya ha llegado!\n",
							productList[indexProduct].productName);
				}
				printf("Producto comprado:\n");
				Product_printOne(productList[indexProduct]);

			}
			if (utn_getNumeroWithMax("1)Cancelar una compra\n0)Salir",
					"Ha habido un error, intentelo nuevamente", 0, 2, 3,
					&option) == 0) {
				int idToCancel;
				switch (option) {
				case 0:
					break;
				case 1:
					if (utn_getNumero(
							"Ingrese el ID del producto que desea cancelar",
							"Ha habido un error, intentelo nuevamente", 0, 3,
							&idToCancel) == 0) {
						int productToCancel = Product_SearchIndexPerId(
								productList, productSize, idToCancel,
								INPROCESS);
						printf(
								"El producto que desea cancelar es el siguiente:\n");
						Product_printOne(productList[productToCancel]);
						if (confirmation(
								"¿Esta seguro que desea cancelarlo? 1-Si / Otro numero-No\n",
								"Ha habido un error.\n") == 1) {
							productList[productToCancel].isEmpty = CANCELLED;
						}
					}
				}
			}

		}
		r = 0;
	}

	return r;
}

